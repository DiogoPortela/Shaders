//#pragma kernel CSTextureRender

#pragma kernel CSCornerSamples
#pragma kernel CSCellData
#pragma kernel CSCalculateFunctionData
#pragma kernel CSDrawOutLine
/*[numthreads(4, 4, 1)]
void CSTextureRender (uint3 id : SV_DispatchThreadID)
{
    float2 uv = id / textureSize;
    uv = uv * meshSize - float2(meshSize, meshSize) / 2;
    float4 color = float4(0, 0, 0, 1);
    float metaballs = 0;

    for(int i = 0; i < arrayCount; i++)
        metaballs += Metaball(uv, blobInstanceArray[i]);
    if(metaballs >= 1)
        color.x = metaballs;

    SmallTexture[id.xy] = color;
}*/

RWTexture2D<float4> SmallTexture;
RWStructuredBuffer<float2> blobInstanceArray;
float textureSize;              //SIZE OF THE CORNERS ARRAY
float blobInstanceArrayCount;   //NUMBER OF INSTANCES TO CALCULATES 
float blobRadius;               //Radius of a blob
float meshSize;                 //Scale of the rendering plane
RWStructuredBuffer<float> cornersData;
RWStructuredBuffer<int> cellsData;

struct functionData{
    float m;
    float b;
};

functionData new_functionData (float m, float b){
    functionData f;
    f.m = m;
    f.b = b;
    return f;
}
RWStructuredBuffer<functionData> cellFunction;

//----------------------------------------------------------------

float Metaball(float2 uv, float2 pos){
    return blobRadius / dot(uv - pos, uv - pos);
}

[numthreads(4,4,1)]
void CSCornerSamples(uint3 id : SV_DISPATCHTHREADID){
    float2 uv = id / textureSize;
    uv = uv * meshSize - float2(meshSize, meshSize) / 2;
    float metaballs = 0;

    for(int i = 0; i < blobInstanceArrayCount; i++)
        metaballs += Metaball(uv, blobInstanceArray[i]);

    SmallTexture[id.xy] = float4(metaballs, 0 , 0 ,1);
    cornersData[id.x + textureSize * id.y] = metaballs;
}
//----------------------------------------------------------------

bool CheckIfPossible(int2 index){
    if(index.x > textureSize || index.y > textureSize)
        return false;
    return true;
}
int GetCornersCoords(int2 pos){
    return pos.x + pos.y * textureSize;
}
int GetCellCoords(int2 pos){
    return pos.x + pos.y * (textureSize - 1);
}
[numthreads(4,4,1)]
void CSCellData(uint3 id : SV_DISPATCHTHREADID){
    int value = 0;

    float4 st = float4(0,0,0,1
    );
    int2 currentPos = int2(id.x, id.y);
    if(cornersData[GetCornersCoords(currentPos)] >= 1.0){ 
        value += 8;
    }

    currentPos = int2(id.x + 1, id.y);
    if(CheckIfPossible(currentPos) && cornersData[GetCornersCoords(currentPos)] >= 1.0){
        value += 1;
    }

    currentPos = int2(id.x, id.y + 1);
    if(CheckIfPossible(currentPos) && cornersData[GetCornersCoords(currentPos)] >= 1.0){
        value += 4;
    }

    currentPos = int2(id.x + 1, id.y + 1);
    if(CheckIfPossible(currentPos) && cornersData[GetCornersCoords(currentPos)] >= 1.0){
        value += 2;
    }

    //SmallTexture[id.xy] = float4(value, 0, 0, 1);
    //SmallTexture[id.xy] = float4(GetCoords(currentPos) / (32.0 * 32.0), 0, 0, 1);
    //cellsData[id.x + id.y * (textureSize - 1)] = value;
    cellsData[GetCellCoords(id.xy)] = value;
    currentPos = int2(id.x, id.y);
}
//----------------------------------------------------------------
functionData CalculateFunction(float2 point1, float2 point2, int2 coords){
    float m = (point1.y - point2.y) / (point1.x - point2.x);
    float b = point1.y - (m * point1.x);
    return new_functionData(m,b);
}
[numthreads(4,4,1)]
void CSCalculateFunctionData(uint3 id : SV_DISPATCHTHREADID){
    int2 uvs = int2(id.x, id.y);
    int cellValue = cellsData[GetCellCoords(uvs)];

    functionData cellFunctionData = new_functionData(0, 0);
    float result = 0;
    if(cellValue == 1 || cellValue == 14){
        cellFunctionData = CalculateFunction(float2(0.0, 0.5), float2(0.5, 0.0), uvs);
    }
    else if(cellValue == 2 || cellValue == 13){
        cellFunctionData = CalculateFunction(float2(0.5, 0.0), float2(0.5, 1.0), uvs);
    }
    else if(cellValue == 3 || cellValue == 12){
        cellFunctionData = CalculateFunction(float2(0.0, 0.5), float2(1.0, 0.5), uvs);
    }
    else if(cellValue == 4 || cellValue == 11){
        cellFunctionData = CalculateFunction(float2(0.5, 1.0), float2(1.0, 0.5), uvs);
    }
    else if(cellValue == 7 || cellValue == 8){
        cellFunctionData = CalculateFunction(float2(0.0, 0.5), float2(0.5, 1.0), uvs);
    }


    /*else if(cellValue == 5 || cellValue == 10){
        cellFunctionData = CalculateFunction(float2( 0, 0), float2( 0, 0), uvs);
    }
    else if(cellValue == 6 || cellValue == 9){
        cellFunctionData = CalculateFunction(float2( 0, 0), float2( 0, 0), uvs);
    }*/

    cellFunction[GetCellCoords(uvs)] = cellFunctionData;
}
//----------------------------------------------------------------

float plotHorizontal(int2 uv, float value){
  return  smoothstep( value - 0.01, value, uv.y) -
          smoothstep( value, value + 0.01, uv.y);
}
float plotVertical(float2 uv, float value){
    return  smoothstep( value - 0.01, value, uv.x) -
            smoothstep( value, value + 0.01, uv.x);
}

RWTexture2D<float4> Result;
[numthreads(8,8,1)]
void CSDrawOutLine(uint3 id : SV_DISPATCHTHREADID){
    int2 cornerUV = int2(id.x * 32 / 256, id.y * 32 / 256);

    int cellValue = cellsData[GetCellCoords(cornerUV)];

    float result = 0;
    
    if(cellValue == 0 || cellValue == 15)
        result = 1;
    //if(cellValue != 5 && cellValue != 10 && cellValue != 6 && cellValue != 9){
        //functionData f = cellFunction[GetCoords(cornerUV)];
        //float value = f.m * (id.x + cornerUV.x) + f.b;
        //result = plotHorizontal(id.xy, value + cornerUV.y);
    //}

    Result[id.xy] = float4(result, 0, 0, 1);
}